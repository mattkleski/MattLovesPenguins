print(coef(model))
# Get some information
summary_model <- summary(model)
cat(sprintf("R^2: %f\n", summary_model$r.squared))
cat(sprintf("Intercept: %f\n", coef(model)[1]))
cat("Columns: ")
print(names(model$model)[-1])  # excluding response variable
cat("Coefficients:")
print(coef(model))
# Get some information
summary_model <- summary(model)
cat(sprintf("R^2: %f\n", summary_model$r.squared))
cat(sprintf("Intercept: %f\n", coef(model)[1]))
cat("Columns: ")
print(names(model$model)[-1])  # excluding response variable
cat("Coefficients Names:")
print(coef(model))
# Get some information
summary_model <- summary(model)
cat(sprintf("R^2: %f\n", summary_model$r.squared))
cat(sprintf("Intercept: %f\n", coef(model)[1]))
cat("Coefficient Names: ")
print(names(model$model)[-1])  # excluding response variable
cat("Coefficients Values:")
print(coef(model))
# Get some information
summary_model <- summary(model)
cat(sprintf("R^2: %f\n", summary_model$r.squared))
cat(sprintf("Intercept: %f\n", coef(model)[1]))
cat("Columns: ")
print(names(model$model)[-1])  # excluding response variable
cat("Coefficient Array:")
print(coef(model))
renv::snapshot()
# Load necessary libraries
library(dplyr)
library(tidymodels)
# Load necessary libraries
library(dplyr)
library(palmerpenguins)
library(broom)
# Get Data
data("penguins")
df <- na.omit(penguins)  # Remove rows with NA values
head(df, 3)  # Display first three rows
# Get Data
data("penguins")
df <- na.omit(penguins)  # Remove rows with NA values
head(df, 3)  # Display first three rows
# Define Model and Fit
# Automatically handles dummy variables for categorical data
model <- lm(body_mass_g ~ bill_length_mm + species + sex, data = df)
# Get some information
summary_model <- summary(model)
cat(sprintf("R^2: %f\n", summary_model$r.squared))
cat(sprintf("Intercept: %f\n", coef(model)[1]))
cat("Columns: ")
print(names(model$model)[-1])  # excluding response variable
cat("Coefficient Array:")
print(coef(model))
# Load necessary libraries
library(dplyr)
library(tidymodels)
library(duckdb)
library(vetiver)
library(pins)
# Load necessary libraries
suppressPackageStartupMessages({
library(dplyr)
library(tidymodels)
library(duckdb)
library(vetiver)
library(pins)
})
# Get Data
con <- dbConnect(duckdb::duckdb(), "my-db.duckdb")
df <- dbGetQuery(con, "SELECT * FROM penguins") %>%
na.omit()
# Get Data
con <- dbConnect(duckdb::duckdb(), "my-db.duckdb")
df <- dbGetQuery(con, "SELECT * FROM penguins") %>%
na.omit()
# Load necessary libraries
library(dplyr)
library(palmerpenguins)
library(broom)
# Get Data
data("penguins")
df <- na.omit(penguins)  # Remove rows with NA values
head(df, 3)  # Display first three rows
# Define Model and Fit
# Automatically handles dummy variables for categorical data
model <- lm(body_mass_g ~ bill_length_mm + species + sex, data = df)
# Get some information
summary_model <- summary(model)
cat(sprintf("R^2: %f\n", summary_model$r.squared))
cat(sprintf("Intercept: %f\n", coef(model)[1]))
cat("Columns: ")
print(names(model$model)[-1])  # excluding response variable
cat("Coefficient Array:")
print(coef(model))
# Load necessary libraries
suppressPackageStartupMessages({
library(dplyr)
library(tidymodels)
library(duckdb)
library(vetiver)
library(pins)
})
# Load necessary libraries
suppressPackageStartupMessages({
library(dplyr)
library(tidymodels)
library(duckdb)
library(vetiver)
library(pins)
})
# Get Data
con <- dbConnect(duckdb::duckdb(), "my-db.duckdb")
df <- dbGetQuery(con, "SELECT * FROM penguins") %>%
na.omit()
con <- dbConnect(duckdb::duckdb(), "my-db.duckdb")
# List all tables
tables <- dbGetQuery(con, "SHOW TABLES")
print(tables)
dbDisconnect(con)
# Get Data
con <- dbConnect(duckdb::duckdb(), "my-db.duckdb")
df <- dbGetQuery(con, "SELECT * FROM penguins") %>%
na.omit()
# Define Model and Fit
model <- linear_reg() %>%
set_engine("lm") %>%
fit(body_mass_g ~ bill_length_mm + species + sex, data = df)
# Get some information
model_summary <- summary(model$fit)
cat(sprintf("R^2: %f\n", model_summary$r.squared))
cat(sprintf("Intercept: %f\n", coef(model$fit)[1]))
cat("Columns: ")
print(names(model_summary$coefficients))
cat("Coefficients: ")
print(coef(model$fit))
# Turn into Vetiver Model
v <- vetiver_model(model, model_name = "penguin_model", id_cols = "row_names")
library(vetiver)
# Assuming `model` is a tidymodels workflow or a model object supported by vetiver
v <- vetiver_model(model, model_name = "penguin_model")
install.packages("tidy")
install.packages("tidymodels")
library(vetiver)
# Assuming `model` is a tidymodels workflow or a model object supported by vetiver
v <- vetiver_model(model, model_name = "penguin_model")
# Get Data
con <- dbConnect(duckdb::duckdb(), "my-db.duckdb")
df <- dbGetQuery(con, "SELECT * FROM penguins") %>%
na.omit()
library(vetiver)
# Assuming `model` is a tidymodels workflow or a model object supported by vetiver
v <- vetiver_model(model, model_name = "penguin_model")
install.packages("vetiver")
install.packages("vetiver")
library(vetiver)
# Assuming `model` is a tidymodels workflow or a model object supported by vetiver
v <- vetiver_model(model, model_name = "penguin_model")
# Get Data
con <- dbConnect(duckdb::duckdb(), "my-db.duckdb")
df <- dbGetQuery(con, "SELECT * FROM penguins") %>%
na.omit()
# Load necessary libraries
suppressPackageStartupMessages({
library(dplyr)
library(tidymodels)
library(duckdb)
library(vetiver)
library(pins)
})
# Load necessary libraries
suppressPackageStartupMessages({
library(dplyr)
library(tidymodels)
library(duckdb)
library(vetiver)
library(pins)
})
library(vetiver)
# Assuming 'model' is your trained model object and 'X' is your prototype data
v <- vetiver_model(model, model_name = "penguin_model", prototype_data = X)
# Load necessary libraries
library(palmerpenguins)  # For the penguins dataset
library(dplyr)           # For data manipulation
library(caret)           # For preprocessing and machine learning
importPackage("caret")
install.packages("caret")
# Load necessary libraries
library(palmerpenguins)  # For the penguins dataset
library(dplyr)           # For data manipulation
library(caret)           # For preprocessing and machine learning
library(modelr)          # For linear models
# Load the penguins dataset
data("penguins", package = "palmerpenguins")
# Load necessary libraries
library(duckdb)         # For DuckDB operations
library(palmerpenguins) # For the penguins dataset
library(dplyr)          # For data manipulation
# Connect to DuckDB
con <- dbConnect(duckdb::duckdb(), "my-db.duckdb")
# Load penguins data into DuckDB if not already present
if (!dbExistsTable(con, "penguins")) {
dbWriteTable(con, "penguins", penguins)
}
# Query data from DuckDB and remove rows with NA values
df <- dbGetQuery(con, "SELECT * FROM penguins") %>%
na.omit()
# View the first 3 rows of the dataframe
head(df, 3)
# Load necessary libraries
library(duckdb)         # For DuckDB operations
library(palmerpenguins) # For the penguins dataset
library(dplyr)          # For data manipulation
library(broom)          # For data manipulation
# Connect to DuckDB
con <- dbConnect(duckdb::duckdb(), "my-db.duckdb")
# Load penguins data into DuckDB if not already present
if (!dbExistsTable(con, "penguins")) {
dbWriteTable(con, "penguins", penguins)
}
# Query data from DuckDB and remove rows with NA values
df <- dbGetQuery(con, "SELECT * FROM penguins") %>%
na.omit()
# View the first 3 rows of the dataframe
head(df, 3)
# Creating dummy variables for categorical features and dropping the first level
X <- df %>%
select(bill_length_mm, species, sex) %>%
dummyVars( ~ ., data = ., fullRank = TRUE) %>%
predict(newdata = .) %>%
data.frame()
# Creating dummy variables for categorical features
# Setup the dummy variables transformation
dummies <- dummyVars(~ bill_length_mm + species + sex, data = df, fullRank = TRUE)
# Apply transformation and convert to data frame
X <- predict(dummies, newdata = df)
X <- data.frame(X)
# Define the response variable
y <- df$body_mass_g
# Combine X and y for fitting the model
data_for_model <- cbind(X, y)
# Fit a linear regression model
model <- lm(y ~ ., data = data_for_model)
# Optionally, view a summary of the model
summary(model)
# Creating dummy variables for categorical features
# Setup the dummy variables transformation
dummies <- dummyVars(~ bill_length_mm + species + sex, data = df, fullRank = TRUE)
# Apply transformation and convert to data frame
X <- predict(dummies, newdata = df)
X <- data.frame(X)
# Define the response variable
y <- df$body_mass_g
# Combine X and y for fitting the model
data_for_model <- cbind(X, y)
# Fit a linear regression model
model <- lm(y ~ ., data = data_for_model)
# Optionally, view a summary of the model
summary(model)
# Creating dummy variables for categorical features
# Setup the dummy variables transformation
dummies <- dummyVars(~ bill_length_mm + species + sex, data = df, fullRank = TRUE)
# Apply transformation and convert to data frame
X <- predict(dummies, newdata = df)
X <- data.frame(X)
# Define the response variable
y <- df$body_mass_g
# Combine X and y for fitting the model
data_for_model <- cbind(X, y)
# Fit a linear regression model
model <- lm(y ~ ., data = data_for_model)
# Calculate R-squared value
r_squared <- summary(model)$r.squared
# Print the R-squared value
print(paste("R^2", r_squared))
# Retrieve the intercept from the model's coefficients
intercept <- coef(model)[1]  # The first element of the coefficients is the intercept
# Print the intercept
print(paste("Intercept", intercept))
# Retrieve column names from the X data frame
columns <- colnames(X)
# Print the column names
print(paste("Columns", paste(columns, collapse=", ")))
# Retrieve column names from the X data frame
columns <- colnames(X)
# Print the column names
print(paste("The columns are", paste(columns, collapse=", ")))
# Retrieve the coefficients from the model
coefficients <- coef(model)
# Print the coefficients
print(paste("Coefficients", toString(coefficients)))
# Retrieve the coefficients from the model
coefficients <- coef(model)
# Print the coefficients
print(paste("The coefficients are", toString(coefficients)))
# Retrieve the coefficients from the model
coefficients <- coef(model)[-1]
# Print the coefficients
print(paste("The coefficients are", toString(coefficients)))
# Load the necessary library
library(vetiver)
# Create the VetiverModel object
v <- vetiver_model(model, "penguin_model", example_data = X)
# Load the necessary library
library(vetiver)
# Create the VetiverModel object with the correct parameter
v <- vetiver_model(model, model_name = "penguin_model", ptype = X)
# Load the necessary library
library(vetiver)
# Ensure the prototype data is specified correctly
ptype_data <- vetiver_ptype(X)
# Load the necessary library
library(vetiver)
# Create the VetiverModel object with the correct prototype data
v <- vetiver_model(model, model_name = "penguin_model", ptype = ptype_data)
# Load the necessary library
library(vetiver)
# Create the VetiverModel object with the correct prototype data
v <- vetiver_model(model, model_name = "penguin_model", ptype = X)
?vetiver
?vetiver_model
# Load the necessary library
library(vetiver)
# Create the VetiverModel object with the correct prototype data
v <- vetiver_model(model, model_name = "penguin_model", prototype() = X)
# Load the necessary library
library(vetiver)
# Create the VetiverModel object with the correct prototype data
v <- vetiver_model(model, model_name = "penguin_model", prototype = X)
# Load the necessary library
library(vetiver)
# Create the VetiverModel object with the correct prototype data
v <- vetiver_model(model, model_name = "penguin_model")
library(pins)
library(vetiver)
# Create a board for pinning models or data
b <- board_folder("data/model")
# Pin the Vetiver model to the board
vetiver_pin_write(b, v, name = "penguin_model")
library(pins)
library(vetiver)
# Create a board for pinning models or data
b <- board_folder("data/model")
# Pin the Vetiver model to the board
vetiver_pin_write(board = b, model = v)
?vetiver_pin_write
# Load the necessary library
library(vetiver)
# Create the VetiverModel object with the correct prototype data
v <- vetiver_model(model, model_name = "penguin_model")
library(pins)
library(vetiver)
# Create a board for pinning models or data
b <- board_folder("data/model")
# Pin the Vetiver model to the board
vetiver_pin_write(board = b, model = v)
# Load the necessary library
library(vetiver)
library(pins)
# Create the VetiverModel object with the correct prototype data
v <- vetiver_model(model, model_name = "penguin_model")
# Create a board for pinning models or data
b <- board_folder("data/model")
# Pin the Vetiver model to the board
vetiver_pin_write(board = b, model = v)
# Create a board for pinning models or data
b <- board_folder("data/model")
# Pin the Vetiver model to the board
vetiver_pin_write(b, v, name = "penguin_model")
# Create a board for pinning models or data
b <- board_folder("data/model")
# Pin the Vetiver model to the board
vetiver_pin_write(b, v)
library(plumber)
app <- vetiver_api(v, check_ptype = TRUE)
?vetiver_api
library(plumber)
app <- vetiver_api(v)
library(plumber)
app <- vetiver_api(v, check_ptype = TRUE)
# Load the necessary library
library(vetiver)
library(pins)
# Create the VetiverModel object with the correct prototype data
v <- vetiver_model(model, model_name = "penguin_model")
# Create a board for pinning models or data
b <- board_folder("data/model")
# Pin the Vetiver model to the board
vetiver_pin_write(b, v)
# Create a board for pinning models or data
b <- board_folder("data/model")
# Pin the Vetiver model to the board
vetiver_pin_write(b, v)
library(plumber)
app <- vetiver_api(v, check_ptype = TRUE)
library(plumber)
app <- vetiver_api(v, check_prototype = TRUE)
library(plumber)
app <- vetiver_api(vetiver_model = v, check_prototype = TRUE)
library(plumber)
app <- vetiver_api(pr = 8080, vetiver_model = v, check_prototype = TRUE)
library(plumber)
pr()
app <- vetiver_api(pr = 8080, vetiver_model = v, check_prototype = TRUE)
library(plumber)
app <- vetiver_api(pr = pr(), vetiver_model = v, check_prototype = TRUE)
library(plumber)
app <- vetiver_api(pr = pr(), vetiver_model = v, check_prototype = TRUE)
# Load the plumber library
# Plumber is used to create HTTP APIs from R functions.
library(plumber)
# Create a Plumber router for the Vetiver model
# `vetiver_api()` sets up a web API for the provided machine learning model.
# Parameters:
#   pr: An empty Plumber router is initialized by calling `pr()`. This serves as the foundation upon which
#       the API endpoints are built. You can also extend this router with additional custom endpoints.
#   vetiver_model: The `v` variable is expected to be a VetiverModel object. This object includes the model
#                  and metadata necessary for making predictions and managing the input data.
#   check_prototype: When set to TRUE, the API automatically checks incoming data against the model's expected
#                    data structure (prototype) before making predictions. This ensures that the data
#                    conforms to the expected format, reducing errors in model execution.
app <- vetiver_api(pr = pr(), vetiver_model = v, check_prototype = TRUE)
# Note: At this point, `app` is a configured Plumber router that can be used to serve the machine learning
# model over a web API. To make the API available for use, you would typically run it on a server with a
# specific command like `pr$run(port=8000)`, which is not shown in this snippet.
# Load the plumber library
# Plumber is used to create HTTP APIs from R functions.
library(plumber)
# Create a Plumber router for the Vetiver model
# `vetiver_api()` sets up a web API for the provided machine learning model.
# Parameters:
#   pr: An empty Plumber router is initialized by calling `pr()`. This serves as the foundation upon which
#       the API endpoints are built. You can also extend this router with additional custom endpoints.
#   vetiver_model: The `v` variable is expected to be a VetiverModel object. This object includes the model
#                  and metadata necessary for making predictions and managing the input data.
#   check_prototype: When set to TRUE, the API automatically checks incoming data against the model's expected
#                    data structure (prototype) before making predictions. This ensures that the data
#                    conforms to the expected format, reducing errors in model execution.
app <- vetiver_api(pr = pr(), vetiver_model = v, check_prototype = TRUE)
# Note: At this point, `app` is a configured Plumber router that can be used to serve the machine learning
# model over a web API. To make the API available for use, you would typically run it on a server with a
# specific command like `pr$run(port=8000)`, which is not shown in this snippet.
# Load the plumber library
# Plumber is used to create HTTP APIs from R functions.
library(plumber)
# Create a Plumber router for the Vetiver model
# `vetiver_api()` sets up a web API for the provided machine learning model.
# Parameters:
#   pr: An empty Plumber router is initialized by calling `pr()`. This serves as the foundation upon which
#       the API endpoints are built. You can also extend this router with additional custom endpoints.
#   vetiver_model: The `v` variable is expected to be a VetiverModel object. This object includes the model
#                  and metadata necessary for making predictions and managing the input data.
#   check_prototype: When set to TRUE, the API automatically checks incoming data against the model's expected
#                    data structure (prototype) before making predictions. This ensures that the data
#                    conforms to the expected format, reducing errors in model execution.
app <- vetiver_api(pr = pr(), vetiver_model = v, check_prototype = TRUE)
# Note: At this point, `app` is a configured Plumber router that can be used to serve the machine learning
# model over a web API. To make the API available for use, you would typically run it on a server with a
# specific command like `pr$run(port=8000)`, which is not shown in this snippet.
pr$run(port=8080)
# Load the plumber library
# Plumber is used to create HTTP APIs from R functions.
library(plumber)
# Create a Plumber router for the Vetiver model
# `vetiver_api()` sets up a web API for the provided machine learning model.
# Parameters:
#   pr: An empty Plumber router is initialized by calling `pr()`. This serves as the foundation upon which
#       the API endpoints are built. You can also extend this router with additional custom endpoints.
#   vetiver_model: The `v` variable is expected to be a VetiverModel object. This object includes the model
#                  and metadata necessary for making predictions and managing the input data.
#   check_prototype: When set to TRUE, the API automatically checks incoming data against the model's expected
#                    data structure (prototype) before making predictions. This ensures that the data
#                    conforms to the expected format, reducing errors in model execution.
app <- vetiver_api(pr = pr(port = 8080), vetiver_model = v, check_prototype = TRUE)
# Load the plumber library
# Plumber is used to create HTTP APIs from R functions.
library(plumber)
# Create a Plumber router for the Vetiver model
# `vetiver_api()` sets up a web API for the provided machine learning model.
# Parameters:
#   pr: An empty Plumber router is initialized by calling `pr()`. This serves as the foundation upon which
#       the API endpoints are built. You can also extend this router with additional custom endpoints.
#   vetiver_model: The `v` variable is expected to be a VetiverModel object. This object includes the model
#                  and metadata necessary for making predictions and managing the input data.
#   check_prototype: When set to TRUE, the API automatically checks incoming data against the model's expected
#                    data structure (prototype) before making predictions. This ensures that the data
#                    conforms to the expected format, reducing errors in model execution.
app <- vetiver_api(pr = pr(8080), vetiver_model = v, check_prototype = TRUE)
# Load the plumber library
# Plumber is used to create HTTP APIs from R functions.
library(plumber)
# Create a Plumber router for the Vetiver model
# `vetiver_api()` sets up a web API for the provided machine learning model.
# Parameters:
#   pr: An empty Plumber router is initialized by calling `pr()`. This serves as the foundation upon which
#       the API endpoints are built. You can also extend this router with additional custom endpoints.
#   vetiver_model: The `v` variable is expected to be a VetiverModel object. This object includes the model
#                  and metadata necessary for making predictions and managing the input data.
#   check_prototype: When set to TRUE, the API automatically checks incoming data against the model's expected
#                    data structure (prototype) before making predictions. This ensures that the data
#                    conforms to the expected format, reducing errors in model execution.
app <- vetiver_api(pr = pr(), vetiver_model = v, check_prototype = TRUE)
# Note: At this point, `app` is a configured Plumber router that can be used to serve the machine learning
# model over a web API. To make the API available for use, you would typically run it on a server with a
# specific command like `pr$run(port=8000)`, which is not shown in this snippet.
reticulate::repl_python()
